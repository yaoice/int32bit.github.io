---
layout: post
title: kubelet源码阅读笔记
subtitle: ""
catalog: true
hide: true
tags:
     - k8s
---

### 环境

- Kubernetes v1.14.6
- Etcd 3.3.12
- Docker 18.09.9

### Kubelet

kubelet是k8s核心组件中最复杂的一个组件，它跟网络、存储、docker都得打交道. 它是每个节点的主要节点agent，向apiserver注册节点

## 远程调试

使用dlv工具来远程调试，dlv相比gdb在调试goroutine等方面支持更好

GOGCFLAGS="-N -l" debug的时候关闭编译优化和内联优化

```
GO111MODULE=off KUBE_GIT_TREE_STATE=clean KUBE_GIT_VERSION=v1.14.6 make kubelet GOFLAGS="-tags=nokmem" GOGCFLAGS="all=-N -l"
```

默认编译参数加上了-s -w，需要去掉

```
vim k8s.io/kubernetes/hack/lib/golang.sh
# goldflags="${GOLDFLAGS:-} -s -w $(kube::version::ldflags)"
goldflags="${GOLDFLAGS:-} $(kube::version::ldflags)"

-s disable symbol table      禁用符号表
-w disable DWARF generation  禁用调试信息
参数帮助信息查看：go tool link
```

运行并启动一个调试端，监听本地IP的2345端口

```
dlv exec /usr/bin/kubelet --headless -l 219.14.1.85:2345 --api-version=2 -- --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf --config=/var/lib/kubelet/config.yaml --cgroup-driver=cgroupfs --hostname-override=9.134.12.85 --network-plugin=cni --pod-infra-container-image=tke3.global.registry.cc.oa.com/tke3/pause:3.1
```

本地连上远程调试地址和端口就可以调试了

```
dlv connect 219.14.1.85:2345
```

### kubelet代码

启动函数

```
k8s.io/kubernetes/cmd/kubelet/kubelet.go -> NewKubeletCommand(初始化命令行对象) -> Run
```

NewKubeletCommand中包括默认参数、默认flag

```
kubeletFlags := options.NewKubeletFlags() // 默认值定义在k8s.io/kubernetes/cmd/kubelet/app/options/options.go
kubeletConfig, err := options.NewKubeletConfiguration() // 默认值定义在k8s.io/kubernetes/pkg/kubelet/apis/config/v1beta1/defaults.go
```

Run函数：

1. 设置featrueGate；

2. 校验命令行参数；

3. 加载kubelet配置文件；

4. 校验kubelet配置；

5. 是否启用动态kubelet配置

6. 构建默认kubelet运行依赖
   - 有dockerClientConfig，跟docker通信；
   - mounter/subpather用于volume挂载；
   - 初始化oomAdjuster对象；
   - 初始化RealOS对象，用于系统级别操作；
   - 检测要被使用的一系列volume插件 // ProbeVolumePlugins()
   - flexvolume方式动态检测volume插件

7. 是否运行dockershim（为kubelet调用提供grpc接口，转化grpc请求为docker的方式）

8. 运行kubelet

   - 操作系统初始化(针对windows平台)

   - 尝试获取kubelet本地文件锁(需要启动时加--exit-on-lock-contention、--lock-file参数)

   - 注册当前kubelet配置到/configz，可通过如下命令获取

     ```
     curl -k  -X GET -H 'Authorization: Bearer 1aYiwwOnSN4Yk5oNm7fov0ohBbk' \
         	https://127.0.0.1:10250/configz
     ```

   - 初始化cloudProvider

   - 初始化eventClientConfig、heartbeatClientConfig

   - 初始化Auth，初始化一个authn、authz对象

   - 初始化cadvisor

   - 初始化ContainerManager

   - 检查运行的uid是否为0

   - 设置0号进程的oom_score_adj，默认为-999；范围是[-1000,1000]; 值越大越容易被OOM kill

   - 进入RunKubelet函数(下面重点)

   - 设置/healthz路由，可通过下面命令验证

     ```
     curl -k  -X GET -H 'Authorization: Bearer 1aYiwwOnSN4Yk5oNm7fov0ohBbk' \
         https://127.0.0.1:10250/healthz   
     ```

   - 如果是sytemd方式启动，通知systemd



RunKubelet函数

 	1. 获取nodeName，可以通过kubelet配置文件进行override
 	2. 获取特权模式的资源HostNetworkSources、HostPIDSources、HostIPCSources，默认都是*
 	3. 初始化一个Capabilities对象(单例)，AllowPrivileged为true
	4. 设置RootDirectory(默认为/var/lib/kubelet)为.docker/config.json的可能存放路径目录
	5. 初始化kubelet对象, createAndInitKubelet（下面重点）
	6. 设置能打开的最大文件数，MaxOpenFiles默认为1000000
	7. startKubelet



createAndInitKubelet函数

```
func createAndInitKubelet(kubeCfg *kubeletconfiginternal.KubeletConfiguration,
	kubeDeps *kubelet.Dependencies,
	crOptions *config.ContainerRuntimeOptions,
	containerRuntime string,
	runtimeCgroups string,
	hostnameOverride string,
	nodeIP string,
	providerID string,
	cloudProvider string,
	certDirectory string,
	rootDirectory string,
	registerNode bool,
	registerWithTaints []api.Taint,
	allowedUnsafeSysctls []string,
	remoteRuntimeEndpoint string,
	remoteImageEndpoint string,
	experimentalMounterPath string,
	experimentalKernelMemcgNotification bool,
	experimentalCheckNodeCapabilitiesBeforeMount bool,
	experimentalNodeAllocatableIgnoreEvictionThreshold bool,
	minimumGCAge metav1.Duration,
	maxPerPodContainerCount int32,
	maxContainerCount int32,
	masterServiceNamespace string,
	registerSchedulable bool,
	nonMasqueradeCIDR string,
	keepTerminatedPodVolumes bool,
	nodeLabels map[string]string,
	seccompProfileRoot string,
	bootstrapCheckpointPath string,
	nodeStatusMaxImages int32) (k kubelet.Bootstrap, err error) {
	// TODO: block until all sources have delivered at least one update to the channel, or break the sync loop
	// up into "per source" synchronizations

	// 进入NewMainKubelet，返回一个带有所有内部必需内部模块的kubelet对象
	k, err = kubelet.NewMainKubelet(kubeCfg,
		kubeDeps,
		crOptions,
		containerRuntime,
		runtimeCgroups,
		hostnameOverride,
		nodeIP,
		providerID,
		cloudProvider,
		certDirectory,
		rootDirectory,
		registerNode,
		registerWithTaints,
		allowedUnsafeSysctls,
		remoteRuntimeEndpoint,
		remoteImageEndpoint,
		experimentalMounterPath,
		experimentalKernelMemcgNotification,
		experimentalCheckNodeCapabilitiesBeforeMount,
		experimentalNodeAllocatableIgnoreEvictionThreshold,
		minimumGCAge,
		maxPerPodContainerCount,
		maxContainerCount,
		masterServiceNamespace,
		registerSchedulable,
		nonMasqueradeCIDR,
		keepTerminatedPodVolumes,
		nodeLabels,
		seccompProfileRoot,
		bootstrapCheckpointPath,
		nodeStatusMaxImages)
	if err != nil {
		return nil, err
	}
	// 发送一个事件"Starting kubelet"
	k.BirthCry()
	// container gc，每隔一分钟执行一次
	// image gc, 每隔5分钟执行一次
	// image gc有上限阀值/下限阀值配置，上限阀值默认85，大等于上限阀值就触发；下限阀值默认80，用于计算要释放的空间
	// 要释放的空间 = 总容量*（100-下限阀值）/100 - 剩余可用
	k.StartGarbageCollection()

	return k, nil
}
```



NewMainKubelet

1. 判断rootDirectory、SyncFrequency.Duration、MakeIPTablesUtilChains、IPTablesMasqueradeBit、IPTablesDropBit值的合法性
2. 获取nodeName
3. 初始化PodConfig

```
// 如何加载static pod的呢？
if kubeDeps.PodConfig == nil {
		var err error
		kubeDeps.PodConfig, err = makePodSourceConfig(kubeCfg, kubeDeps, nodeName, bootstrapCheckpointPath)
		if err != nil {
			return nil, err
		}
	}

// makePodSourceConfig creates a config.PodConfig from the given
// KubeletConfiguration or returns an error.
func makePodSourceConfig(kubeCfg *kubeletconfiginternal.KubeletConfiguration, kubeDeps *Dependencies, nodeName types.NodeName, bootstrapCheckpointPath string) (*config.PodConfig, error) {
	// 是否有设置StaticPodURLHeader
	manifestURLHeader := make(http.Header)
	if len(kubeCfg.StaticPodURLHeader) > 0 {
		for k, v := range kubeCfg.StaticPodURLHeader {
			for i := range v {
				manifestURLHeader.Add(k, v[i])
			}
		}
	}
	// 初始化一个PodConfig对象
	// source of all configuration
	cfg := config.NewPodConfig(config.PodConfigNotificationIncremental, kubeDeps.Recorder)

	// define file config source
	if kubeCfg.StaticPodPath != "" {
		klog.Infof("Adding pod path: %v", kubeCfg.StaticPodPath)
		// 默认间隔20s, 读取static_path下的所有内容
		config.NewSourceFile(kubeCfg.StaticPodPath, nodeName, kubeCfg.FileCheckFrequency.Duration, cfg.Channel(kubetypes.FileSource))
	}

	// define url config source
	if kubeCfg.StaticPodURL != "" {
		klog.Infof("Adding pod url %q with HTTP header %v", kubeCfg.StaticPodURL, manifestURLHeader)
		config.NewSourceURL(kubeCfg.StaticPodURL, manifestURLHeader, nodeName, kubeCfg.HTTPCheckFrequency.Duration, cfg.Channel(kubetypes.HTTPSource))
	}

	// Restore from the checkpoint path
	// NOTE: This MUST happen before creating the apiserver source
	// below, or the checkpoint would override the source of truth.

	var updatechannel chan<- interface{}
	if bootstrapCheckpointPath != "" {
		klog.Infof("Adding checkpoint path: %v", bootstrapCheckpointPath)
		updatechannel = cfg.Channel(kubetypes.ApiserverSource)
		err := cfg.Restore(bootstrapCheckpointPath, updatechannel)
		if err != nil {
			return nil, err
		}
	}

	if kubeDeps.KubeClient != nil {
		klog.Infof("Watching apiserver")
		if updatechannel == nil {
			updatechannel = cfg.Channel(kubetypes.ApiserverSource)
		}
		// watch apiserver获取该节点下所有的pod信息，传入cfg.Channel(kubetypes.ApiserverSource)
		config.NewSourceApiserver(kubeDeps.KubeClient, nodeName, updatechannel)
	}
	return cfg, nil
}
```

4.  初始化containerGCPolicy，容器垃圾回收的策略
5.  初始化daemonEndpoints,  kubelet运行监听的端口
6. 初始化imageGCPolicy，镜像垃圾回收的策略
7. 初始化evictionConfig
8. 初始化一个Kubelet对象
9. 初始化一个cloudResourceSyncManager对象，用于处理跟cloud provider交互的请求
10. 初始化secretManager、configMapManager对象，默认ConfigMapAndSecretChangeDetectionStrategy是Watch
11. 初始化machineInfo
12. 初始化一个流控对象imageBackOff，用于镜像下载失败重试







### 参考链接

- [https://blog.tianfeiyu.com/source-code-reading-notes/kubernetes/kubelet_init.html](https://blog.tianfeiyu.com/source-code-reading-notes/kubernetes/kubelet_init.html)